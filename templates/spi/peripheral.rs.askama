{% let d = d %}

use core::marker::PhantomData;
use crate::{ set_bit_itf, clear_bit_itf, write_val_itf, read_val, is_set, Result, Error, clocks::Clocks };
use super::*;

pub trait FrameFormat {
  fn setup();
  fn teardown();
}

pub struct MotorolaFrameFormat { }
impl FrameFormat for MotorolaFrameFormat {
  fn setup() {
    {{clear_bit!(d, self.spi.frf_field)}};
  }

  fn teardown() {
    {{reset!(d, self.spi.frf_field)}};
  }
}

pub struct TiFrameFormat { }
impl FrameFormat for TiFrameFormat {
  fn setup() {
    {{set_bit!(d, self.spi.frf_field)}};
  }

  fn teardown() {
    {{reset!(d, self.spi.frf_field)}};
  }
}

pub trait Role {
  fn setup();
  fn teardown();
}

pub struct MasterRole {}
impl Role for MasterRole {
  fn setup() {
    {{set_bit!(d, self.spi.mstr_field)}};
  }

  fn teardown() {
    {{reset!(d, self.spi.mstr_field)}};
  }
}

pub struct SlaveRole {}
impl Role for SlaveRole {
  fn setup() {
    {{clear_bit!(d, self.spi.mstr_field)}};
  }

  fn teardown() {
    {{reset!(d, self.spi.mstr_field)}};
  }
}

pub trait Protocol {
  fn setup();
  fn teardown();
}

pub struct SpiProtocol {}
impl Protocol for SpiProtocol {
  fn setup() { }

  fn teardown() { }
}

pub struct I2sProtocol {}
impl Protocol for I2sProtocol {
  fn setup() { }

  fn teardown() { }
}


pub struct SpiI2s{{spi.number}} { 
  _no_construct: (),
}
impl SpiI2s{{spi.number}} {

  pub(crate) fn create(clocks: &Clocks) -> Result<Self> {
    Ok(Self {
      _no_construct: (),
    })
  }

  pub(crate) fn enable(&mut self) {
    {{set_bit!(d, self.spi.peripheral_enable_field)}};
  }

  pub(crate) fn disable(&mut self) -> Result<()> {
    {{clear_bit!(d, self.spi.peripheral_enable_field)}};
    Ok(())
  }

  pub fn as_spi<P, F, R>(mut self) -> Spi<P, F, R> 
  where 
    P: Protocol,
    F: FrameFormat,
    R: Role
  {
    let mut spi = Spi {
      protocol: PhantomData {},
      frame_format: PhantomData {},
      role: PhantomData {},
    };

    spi.setup();

    spi
  }
}



pub struct Spi<P, F, R> 
where 
  P: Protocol,
  F: FrameFormat,
  R: Role
{
  protocol: PhantomData<P>,
  frame_format: PhantomData<F>,
  role: PhantomData<R>,
}
impl<P, F, R> Spi<P, F, R> 
where 
  P: Protocol,
  F: FrameFormat,
  R: Role
{
  fn setup(&mut self) {
    P::setup();
    F::setup();
    R::setup();

    {{clear_bit!(d, self.spi.i2smod_field)}};
    
  }

  pub fn start(&mut self) {
    {{set_bit!(d, self.spi.spe_field)}};
  }

  pub fn stop(&mut self) {
    {{clear_bit!(d, self.spi.spe_field)}};
  }

  pub fn write(&self, val: u16) {
    {{write_val!(d, self.spi.dr_field, "val as u32")}};
  }

  pub fn read(&self) -> u16 {
    {{read_val!(d, self.spi.dr_field)}} as u16
  }

  pub fn enable_software_slave_management(&mut self) {
    {{set_bit!(d, self.spi.ssm_field)}};
  }

  pub fn disable_software_slave_management(&mut self) {
    {{clear_bit!(d, self.spi.ssm_field)}};
  }

  pub fn is_software_slave_management_disabled(&mut self) -> bool {
    {{is_set!(d, self.spi.ssm_field)}}
  }

  pub fn set_internal_slave_select(&mut self) {
    {{set_bit!(d, self.spi.ssi_field)}};
  }

  pub fn clear_internal_slave_select(&mut self) {
    {{clear_bit!(d, self.spi.ssi_field)}};
  }

  pub fn set_bit_order(&mut self, order: BitOrder) {
    {{write_val!(d, self.spi.lsbfirst_field, "order as u32")}}; 
  }

  pub fn get_bit_order(&mut self) -> BitOrder {
    match {{is_set!(d, self.spi.lsbfirst_field)}} {
      true => BitOrder::LsbFirst,
      false => BitOrder::MsbFirst,
    } 
  }

  pub fn set_clock_phase(&mut self, order: ClockPhase) {
    {{write_val!(d, self.spi.cpha_field, "order as u32")}}; 
  }

  pub fn get_clock_phase(&mut self) -> ClockPhase {
    match {{is_set!(d, self.spi.cpha_field)}} {
      true => ClockPhase::FirstTransition,
      false => ClockPhase::SecondTransition,
    } 
  }

  pub fn set_clock_polarity(&mut self, order: ClockPolarity) {
    {{write_val!(d, self.spi.cpol_field, "order as u32")}}; 
  }

  pub fn get_clock_polarity(&mut self) -> ClockPolarity {
    match {{is_set!(d, self.spi.cpol_field)}} {
      true => ClockPolarity::IdleLow,
      false => ClockPolarity::IdleHigh,
    } 
  }

  pub fn set_data_size(&mut self, num_bits: u32) -> Result<()> {
    match num_bits {
      n if n >= 4 && n <= 16 => { 
        {{write_val!(d, self.spi.ds_field, "n - 1")}}; 
        Ok(())
      },
      _ => Err(Error::new("Data size must be from 4 to 16 bits"))
    }
  }

  pub fn teardown(mut self) -> SpiI2s{{spi.number}} { 
    P::teardown();
    F::teardown();
    R::teardown();

    SpiI2s{{spi.number}} { 
      _no_construct: ()
    }
  }
}



