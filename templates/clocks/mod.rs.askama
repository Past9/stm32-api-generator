use crate::{ set_bit, clear_bit, write_val, wait_for_val, wait_for_clear, wait_for_set, Result, is_set };
use cortex_m::interrupt;

{% let d = device %}

// Multiplexer input options
{% for mux in multiplexers %}
#[derive(Copy, Clone)]
pub enum {{mux.struct_name}}Input {
  {% for mux_in in mux.inputs -%}
  {{mux_in.struct_name}} = {{mux_in.bit_value}},
  {% endfor %}
}
{% endfor %}


// Divider value options
{% for div in variable_dividers %}
#[derive(Copy, Clone)]
pub enum {{div.struct_name}}Value {
  {% for div_opt in div.options -%} 
  {{div_opt.struct_name}} = {{div_opt.bit_value}},
  {% endfor %}
}
{% endfor %}


// Multiplier value options
{% for mul in variable_multipliers %}
#[derive(Copy, Clone)]
pub enum {{mul.struct_name}}Value {
  {% for mul_opt in mul.options -%} 
  {{mul_opt.struct_name}} = {{mul_opt.bit_value}},
  {% endfor %}
}
{% endfor %}


pub struct ClockConfig {
  // Oscillator frequencies 
  {% for osc in oscillators -%}
  {{osc.name}}_freq: u64,
  {% endfor %}
  
  // Multiplexer inputs
  {% for mux in multiplexers -%}
  {{mux.field_name}}_input: {{mux.struct_name}}Input,
  {% endfor %}
  
  // Configurable divider inputs
  {% for div in variable_dividers -%}
  {{div.field_name}}_value: {{div.struct_name}}Value,
  {% endfor %}
  
  // Configurable multiplier inputs
  {% for mul in variable_multipliers -%}
  {{mul.field_name}}_value: {{mul.struct_name}}Value,
  {% endfor %}
}
impl ClockConfig {
  pub fn with_freqs(
    {% for osc in oscillators -%}
    {% if osc.is_external %}
    {{osc.name}}_freq: u64,
    {% endif %}
    {% endfor %}
  ) -> ClockConfig {
    ClockConfig {
      // Oscillator frequencies 
      {% for osc in oscillators -%}
      {% if osc.is_external %}
      {{osc.name}}_freq,
      {% else %}
      {{osc.name}}_freq: {{osc.default_freq}},
      {% endif %}
      {% endfor %}

      // Multiplexer inputs
      {% for mux in multiplexers -%}
      {{mux.field_name}}_input: {{mux.struct_name}}Input::{{mux.default.struct_name}},
      {% endfor %}

      // Configurable divider values
      {% for div in variable_dividers -%}
      {{div.field_name}}_value: {{div.struct_name}}Value::{{div.default.struct_name}},
      {% endfor %}

      // Configurable multiplier values
      {% for mul in variable_multipliers -%}
      {{mul.field_name}}_value: {{mul.struct_name}}Value::{{mul.default.struct_name}},
      {% endfor %}
    }
  }

  pub fn with_default_freqs() -> ClockConfig {
    Self::with_freqs(
      {% for osc in oscillators -%}
      {% if osc.is_external %}
      {{osc.default_freq}},
      {% endif %}
      {% endfor %}
    )
  }

  {% for osc in oscillators %}
  fn get_{{osc.name}}_freq(&self) -> f32 {
    self.{{osc.name}}_freq as f32
  }
  {% if osc.is_external %}
  pub fn is_{{osc.name}}_ready(&self) -> bool {
    {{is_set!(d, osc.ext_ready)}}
  }
  {% endif %}
  {% endfor %}


  {% for mux in multiplexers %}
  pub fn get_{{mux.field_name}}_freq(&self) -> f32 {
    match self.{{mux.field_name}}_input {
      {% for mux_in in mux.inputs -%}
      {% if mux_in.is_off -%}
      {{mux.struct_name}}Input::{{mux_in.struct_name}} => 0f32,
      {% else -%}
      {{mux.struct_name}}Input::{{mux_in.struct_name}} => self.get_{{mux_in.real_field_name}}_freq(),
      {%- endif -%}
      {% endfor %}
    }
  }

  pub fn get_{{mux.field_name}}_input(&self) -> &{{mux.struct_name}}Input {
    &self.{{mux.field_name}}_input
  }

  pub fn set_{{mux.field_name}}_input(&mut self, input: {{mux.struct_name}}Input) {
    self.{{mux.field_name}}_input = input
  }
  {% endfor %}

  {% for div in variable_dividers %}
  pub fn get_{{div.field_name}}_freq(&self) -> f32 {
    self.get_{{div.input_field_name}}_freq() / match self.{{div.field_name}}_value {
      {% for div_opt in div.options -%}
      {{div.struct_name}}Value::{{div_opt.struct_name}} => {{div_opt.divisor}}f32,
      {% endfor %}
    }
  }

  pub fn get_{{div.field_name}}_divisor(&self) -> &{{div.struct_name}}Value {
    &self.{{div.field_name}}_value
  }

  pub fn set_{{div.field_name}}_divisor(&mut self, divisor: {{div.struct_name}}Value) {
    self.{{div.field_name}}_value = divisor
  }
  {% endfor %}

  {% for div in fixed_dividers %}
  pub fn get_{{div.field_name}}_freq(&self) -> f32 {
    self.get_{{div.input_field_name}}_freq() / {{div.divisor}}f32
  }
  {% endfor %}

  {% for mul in variable_multipliers %}
  pub fn get_{{mul.field_name}}_freq(&self) -> f32 {
    self.get_{{mul.input_field_name}}_freq() * match self.{{mul.field_name}}_value {
      {% for mul_opt in mul.options -%}
      {{mul.struct_name}}Value::{{mul_opt.struct_name}} => {{mul_opt.factor}}f32,
      {% endfor %}
    }
  }

  pub fn get_{{mul.field_name}}_factor(&self) -> &{{mul.struct_name}}Value {
    &self.{{mul.field_name}}_value
  }

  pub fn set_{{mul.field_name}}_factor(&mut self, factor: {{mul.struct_name}}Value) {
    self.{{mul.field_name}}_value = factor
  }
  {% endfor %}

  {% for mul in fixed_multipliers %}
  fn get_{{mul.field_name}}_freq(&self) -> f32 {
    self.get_{{mul.input_field_name}}_freq() * {{mul.factor}}f32
  }
  {% endfor %}

  {% for tap in taps -%}
  {%- if tap.is_terminal -%}pub{%- endif %}
  fn get_{{tap.field_name}}_freq(&self) -> f32 {
    self.get_{{tap.input_field_name}}_freq()
  }
  {% endfor %}
}


pub(crate) struct Clocks {
  config: ClockConfig
}
impl Clocks {
  pub(crate) fn new(config: ClockConfig) -> Result<Clocks> {
    let mut clocks = Clocks {
      config
    };

    interrupt::free(|_| -> Result<()> {
      clocks.stop()?;
      clocks.write_config();
      clocks.start()?;
      Ok(())
    })?;

    Ok(clocks)
  }

  pub fn get_config(&self) -> &ClockConfig {
    &self.config
  } 


  fn stop(&mut self) -> Result<()> {
    {% for osc in oscillators %} 
    {% if osc.is_external %}
    // Make sure the {{osc.name}} oscillator is not the system clock by resetting 
    // the system clock mux to its default input.                                 
    // ################################################################################
    {{write_val!(d, self.sys_clk_mux.path, self.sys_clk_mux.default.bit_value, false)}};

    // Power off the {{osc.name}} oscillator and wait for it 
    // to be reported off.                                   
    // ###########################################################
    {{clear_bit!(d, osc.ext_power, false)}}; 
    {{wait_for_clear!(d, osc.ext_ready, false)}}?; 
    {% endif %}
    {% endfor %}

    {% if has_pll %}
    // Make sure the PLL is not the system clock by resetting 
    // the system clock mux to is default input.              
    // ############################################################
    {{write_val!(d, self.sys_clk_mux.path, self.sys_clk_mux.default.bit_value, false)}};


    // Turn off the PLL and wait for it to report ready 
    // ######################################################
    {{clear_bit!(d, self.pll_power, false)}};
    {{wait_for_clear!(d, self.pll_ready, false)}}?; 
    {% endif %}

    Ok(())
  }

  fn write_config(&mut self) {
    self.write_multiplexer_config();
    self.write_divider_config();
    self.write_multiplier_config();
  }

  fn write_multiplexer_config(&mut self) {
    {% for mux in multiplexers %}
    {% if !mux.is_sys_clk_mux %}
    {{write_val!(d, mux.path, f!("self.config.{mux.field_name}_input as u32"), false)}};
    {% endif %}
    {% endfor %}
  } 

  fn write_divider_config(&mut self) {
    {% for div in variable_dividers %}
    {{write_val!(d, div.path, f!("self.config.{div.field_name}_value as u32"), false)}};
    {% endfor %}
  }

  fn write_multiplier_config(&mut self) {
    {% for mul in variable_multipliers %}
    {{write_val!(d, mul.path, f!("self.config.{mul.field_name}_value as u32"), false)}};
    {% endfor %}
  }

  fn start(&mut self) -> Result<()> {
    {% for osc in oscillators %} 
    {% if osc.is_external %}
    // Power up the {{osc.name}} oscillator and wait for it 
    // to report ready.                                     
    // ##########################################################
    if self.config.{{osc.name}}_freq != 0 {
      {{set_bit!(d, osc.ext_power, false)}};
      {{wait_for_set!(d, osc.ext_ready, false)}}?; 
    }
    {% endif %}
    {% endfor %}

    {% if has_pll %}
    // Turn on the PLL and wait for it to report ready 
    // #####################################################
    {{set_bit!(d, self.pll_power, false)}}; 
    {{wait_for_set!(d, self.pll_ready, false)}}?; 
    {% endif %}

    // Set the flash latency depending on the clock speed 
    // ########################################################
    let freq = self.config.get_{{sys_clk_mux.field_name}}_freq();
    {% for range in flash_latency.ranges %}
    if 
    {% if range.has_min %}{{range.min_code}}{% endif %}
    {% if range.has_min && range.has_max %}&&{% endif %}
    {% if range.has_max %}{{range.max_code}}{% endif %}
    {
      {{write_val!(d, self.flash_latency.path, range.bit_value, false)}};
    }
    {% endfor %}

    // Select the system clock. We do this after turning on the PLL in 
    // case the PLL is selected as the system clock source.            
    // #####################################################################
    {% for mux in multiplexers %}
    {% if mux.is_sys_clk_mux %}
    {{write_val!(d, mux.path, f!("self.config.{mux.field_name}_input as u32"), false)}};
    {% endif %}
    {% endfor %}

    Ok(())
  }
}