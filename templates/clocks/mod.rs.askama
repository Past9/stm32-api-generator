use crate::{ set_bit, clear_bit, write_val, wait_for_val, wait_for_clear, wait_for_set, Result, Error, is_set, read_val };
use cortex_m::interrupt;

{% let d = device %}

// Multiplexer input options
{% for mux in multiplexers %}
#[derive(Copy, Clone, PartialEq)]
pub enum {{mux.struct_name}}Input {
  {% for mux_in in mux.inputs -%}
  {{mux_in.struct_name}} = {{mux_in.bit_value}},
  {% endfor %}
}
{% endfor %}


// Divider value options
{% for div in configurable_dividers %}
#[derive(Copy, Clone, PartialEq)]
pub enum {{div.struct_name}}Value {
  {% for div_opt in div.options -%} 
  {{div_opt.struct_name}} = {{div_opt.bit_value}},
  {% endfor %}
}
{% endfor %}


// Multiplier value options
{% for mul in configurable_multipliers %}
#[derive(Copy, Clone, PartialEq)]
pub enum {{mul.struct_name}}Value {
  {% for mul_opt in mul.options -%} 
  {{mul_opt.struct_name}} = {{mul_opt.bit_value}},
  {% endfor %}
}
{% endfor %}


pub struct ClockConfig {
  _no_construct: (),

  // Oscillator settings 
  {% for osc in oscillators -%}
  {{osc.name}}_freq: u64,
  {% if osc.is_external %}
  {{osc.name}}_bypass: bool,
  {% endif %}
  {% endfor %}
  
  // Multiplexer inputs
  {% for mux in multiplexers -%}
  {{mux.field_name}}_input: {{mux.struct_name}}Input,
  {% endfor %}
  
  // Configurable divider inputs
  {% for div in configurable_dividers -%}
  {{div.field_name}}_value: {{div.struct_name}}Value,
  {% endfor %}
  
  // Configurable multiplier inputs
  {% for mul in configurable_multipliers -%}
  {{mul.field_name}}_value: {{mul.struct_name}}Value,
  {% endfor %}
}
impl ClockConfig {
  pub fn with_freqs(
    {% for osc in oscillators -%}
    {% if osc.is_external %}
    {{osc.name}}_freq: u64,
    {% endif %}
    {% endfor %}
  ) -> ClockConfig {
    ClockConfig {
      _no_construct: (),

      // Oscillator settings 
      {% for osc in oscillators -%}
      {% if osc.is_external %}
      {{osc.name}}_freq,
      {{osc.name}}_bypass: false,
      {% else %}
      {{osc.name}}_freq: {{osc.default_freq}},
      {% endif %}
      {% endfor %}

      // Multiplexer inputs
      {% for mux in multiplexers -%}
      {{mux.field_name}}_input: {{mux.struct_name}}Input::{{mux.default.struct_name}},
      {% endfor %}

      // Configurable divider values
      {% for div in configurable_dividers -%}
      {{div.field_name}}_value: {{div.struct_name}}Value::{{div.default.struct_name}},
      {% endfor %}

      // Configurable multiplier values
      {% for mul in configurable_multipliers -%}
      {{mul.field_name}}_value: {{mul.struct_name}}Value::{{mul.default.struct_name}},
      {% endfor %}
    }
  }

  pub fn with_default_freqs() -> ClockConfig {
    Self::with_freqs(
      {% for osc in oscillators -%}
      {% if osc.is_external %}
      {{osc.default_freq}},
      {% endif %}
      {% endfor %}
    )
  }

  {% for osc in oscillators %}
  pub fn {{osc.name}}_freq(&self) -> f32 {
    self.{{osc.name}}_freq as f32
  }
  {% if osc.is_external %}
  pub fn bypass_{{osc.name}}(&mut self, bypass: bool) {
    self.{{osc.name}}_bypass = bypass;
  }

  pub fn is_{{osc.name}}_bypassed(&mut self) -> bool {
    self.{{osc.name}}_bypass
  }
  {% endif %}
  {% endfor %}


  {% for mux in multiplexers %}
  pub fn {{mux.field_name}}_freq(&self) -> f32 {
    match self.{{mux.field_name}}_input {
      {% for mux_in in mux.inputs -%}
      {% if mux_in.is_off -%}
      {{mux.struct_name}}Input::{{mux_in.struct_name}} => 0f32,
      {% else -%}
      {{mux.struct_name}}Input::{{mux_in.struct_name}} => self.{{mux_in.real_field_name}}_freq(),
      {%- endif -%}
      {% endfor %}
    }
  }

  pub fn {{mux.field_name}}_input(&self) -> &{{mux.struct_name}}Input {
    &self.{{mux.field_name}}_input
  }

  pub fn set_{{mux.field_name}}_input(&mut self, input: {{mux.struct_name}}Input) {
    self.{{mux.field_name}}_input = input
  }
  {% endfor %}

  {% for div in configurable_dividers %}
  pub fn {{div.field_name}}_freq(&self) -> f32 {
    self.{{div.input_field_name}}_freq() / match self.{{div.field_name}}_value {
      {% for div_opt in div.options -%}
      {{div.struct_name}}Value::{{div_opt.struct_name}} => {{div_opt.divisor}}f32,
      {% endfor %}
    }
  }

  pub fn {{div.field_name}}_divisor(&self) -> &{{div.struct_name}}Value {
    &self.{{div.field_name}}_value
  }

  pub fn set_{{div.field_name}}_divisor(&mut self, divisor: {{div.struct_name}}Value) {
    self.{{div.field_name}}_value = divisor
  }
  {% endfor %}

  {% for div in fixed_dividers %}
  pub fn {{div.field_name}}_freq(&self) -> f32 {
    self.{{div.input_field_name}}_freq() / {{div.divisor}}f32
  }
  {% endfor %}

  {% for mul in configurable_multipliers %}
  pub fn {{mul.field_name}}_freq(&self) -> f32 {
    self.{{mul.input_field_name}}_freq() * match self.{{mul.field_name}}_value {
      {% for mul_opt in mul.options -%}
      {{mul.struct_name}}Value::{{mul_opt.struct_name}} => {{mul_opt.factor}}f32,
      {% endfor %}
    }
  }

  {% for mul in conditional_multipliers %}
  pub fn {{mul.field_name}}_freq(&self) -> f32 {
    self.{{mul.input_field_name}}_freq() * match self.{{mul.input_field_name}}_value {
      {% for mul_cond in mul.conditions -%}
      {{mul.input_struct_name}}Value::{{mul_cond.when}} => {{mul_cond.factor}}f32,
      {% endfor -%}
      _ => {{mul.default}}f32
    }
  }
  {% endfor %}

  pub fn {{mul.field_name}}_factor(&self) -> &{{mul.struct_name}}Value {
    &self.{{mul.field_name}}_value
  }

  pub fn set_{{mul.field_name}}_factor(&mut self, factor: {{mul.struct_name}}Value) {
    self.{{mul.field_name}}_value = factor
  }
  {% endfor %}

  {% for mul in fixed_multipliers %}
  pub fn {{mul.field_name}}_freq(&self) -> f32 {
    self.{{mul.input_field_name}}_freq() * {{mul.factor}}f32
  }
  {% endfor %}

  {% for tap in taps -%}
  pub fn {{tap.field_name}}_freq(&self) -> f32 {
    self.{{tap.input_field_name}}_freq()
  }
  {% endfor %}

  pub fn check_against_expected(&self, expected: &ClockConfig) -> Result<()> {
    // Check oscillators
    {% for osc in oscillators -%}
    {% if osc.is_external %}
    if self.{{osc.name}}_bypass != expected.{{osc.name}}_bypass {
      return Err(Error::new("Clock config mismatch on {{osc.name}}_bypass"));
    }
    {% endif %}
    {% endfor %}


    // Check multiplexers
    {% for mux in multiplexers %}
    if self.{{mux.field_name}}_input != expected.{{mux.field_name}}_input {
      return Err(Error::new("Clock config mismatch on {{mux.field_name}}_input"));
    }
    {% endfor %}

    // Check multipliers
    {% for div in configurable_dividers %}
    if self.{{div.field_name}}_value != expected.{{div.field_name}}_value {
      return Err(Error::new("Clock config mismatch on {{div.field_name}}_value"));
    }
    {% endfor %}

    // Check dividers
    {% for mul in configurable_multipliers %}
    if self.{{mul.field_name}}_value != expected.{{mul.field_name}}_value {
      return Err(Error::new("Clock configuration {{mul.field_name}}_value differs from expected value."));
    }
    {% endfor %}
    Ok(())
  }
}


pub struct Clocks {
  _no_construct: (),
  config: ClockConfig
}
impl Clocks {
  pub(crate) fn new(config: ClockConfig) -> Result<Clocks> {
    let mut clocks = Clocks {
      _no_construct: (),
      config
    };

    interrupt::free(|_| -> Result<()> {
      clocks.stop()?;
      clocks.write_config();
      clocks.start()?;
      Ok(())
    })?;

    clocks.check_config()?;

    Ok(clocks)
  }

  pub fn check_config(&self) -> Result<()> {
    self.config.check_against_expected(&self.actual_config()?)
  }

  pub fn requested_config(&self) -> &ClockConfig {
    &self.config
  } 

  pub fn actual_config(&self) -> Result<ClockConfig> {
    Ok(ClockConfig {
      _no_construct: (),

      // Oscillator settings 
      {% for osc in oscillators -%}
      {% if osc.is_external %}
      {{osc.name}}_freq: self.config.{{osc.name}}_freq,
      {{osc.name}}_bypass: {{is_set!(d, osc.ext_bypass)}},
      {% else %}
      {{osc.name}}_freq: {{osc.default_freq}},
      {% endif %}
      {% endfor %}

      // Multiplexer inputs
      {% for mux in multiplexers -%}
      {{mux.field_name}}_input: match {{read_val!(d, mux.path)}} {
        {% for input in mux.inputs -%}
        {{input.bit_value}} => {{mux.struct_name}}Input::{{input.struct_name}},
        {% endfor -%}
        _ => { return Err(Error::new("Unrecognized input selected for {{mux.field_name}}_input")); }
      },
      {% endfor %}

      // Configurable divider values
      {% for div in configurable_dividers -%}
      {{div.field_name}}_value: match {{read_val!(d, div.path)}} {
        {% for option in div.options -%}
        {{option.bit_value}} => {{div.struct_name}}Value::{{option.struct_name}},
        {% endfor -%}
        _ => { return Err(Error::new("Unrecognized divisor selected for {{div.field_name}}_value")); }
      },
      {% endfor %}

      // Configurable multiplier values
      {% for mul in configurable_multipliers -%}
      {{mul.field_name}}_value: match {{read_val!(d, mul.path)}} {
        {% for option in mul.options -%}
        {{option.bit_value}} => {{mul.struct_name}}Value::{{option.struct_name}},
        {% endfor -%}
        _ => { return Err(Error::new("Unrecognized factor selected for {{mul.field_name}}_value")); }
      },
      {% endfor %}
    })
  }

  {% for osc in oscillators %}
  {% if osc.is_external %}
  pub fn is_{{osc.name}}_on(&self) -> bool {
    {{is_set!(d, osc.ext_power)}}
  }

  pub fn is_{{osc.name}}_ready(&self) -> bool {
    {{is_set!(d, osc.ext_ready)}}
  }

  pub fn is_{{osc.name}}_bypassed(&self) -> bool {
    {{is_set!(d, osc.ext_bypass)}}
  }
  {% endif %}
  {% endfor %}


  fn stop(&mut self) -> Result<()> {
    {% for osc in oscillators %} 
    {% if osc.is_external %}
    // Make sure the {{osc.name}} oscillator is not the system clock by resetting 
    // the system clock mux to its default input.                                 
    // ################################################################################
    {{write_val!(d, self.sys_clk_mux.path, self.sys_clk_mux.default.bit_value, false)}};

    // Power off the {{osc.name}} oscillator and wait for it 
    // to be reported off.                                   
    // ###########################################################
    {{clear_bit!(d, osc.ext_power, false)}}; 
    {{wait_for_clear!(d, osc.ext_ready, false)}}?; 
    {% endif %}
    {% endfor %}

    {% if has_pll %}
    // Make sure the PLL is not the system clock by resetting 
    // the system clock mux to is default input.              
    // ############################################################
    {{write_val!(d, self.sys_clk_mux.path, self.sys_clk_mux.default.bit_value, false)}};


    // Turn off the PLL and wait for it to report ready 
    // ######################################################
    {{clear_bit!(d, self.pll_power, false)}};
    {{wait_for_clear!(d, self.pll_ready, false)}}?; 
    {% endif %}

    Ok(())
  }

  fn write_config(&mut self) {
    self.write_multiplexer_config();
    self.write_divider_config();
    self.write_multiplier_config();
  }

  fn write_multiplexer_config(&mut self) {
    {% for mux in multiplexers -%}
    {% if !mux.is_sys_clk_mux -%}
    {{write_val!(d, mux.path, f!("self.config.{mux.field_name}_input as u32"), false)}};
    {%- endif -%}
    {% endfor %}
  } 

  fn write_divider_config(&mut self) {
    {% for div in configurable_dividers -%}
    {{write_val!(d, div.path, f!("self.config.{div.field_name}_value as u32"), false)}};
    {% endfor %}
  }

  fn write_multiplier_config(&mut self) {
    {% for mul in configurable_multipliers -%}
    {{write_val!(d, mul.path, f!("self.config.{mul.field_name}_value as u32"), false)}};
    {% endfor %}
  }

  fn start(&mut self) -> Result<()> {
    {% for osc in oscillators %} 
    {% if osc.is_external %}
    if self.config.{{osc.name}}_freq != 0 {
      // Power up the {{osc.name}} oscillator and wait for it 
      // to report ready.                                     
      // ##########################################################
      {{set_bit!(d, osc.ext_bypass, false)}};
      {{set_bit!(d, osc.ext_power, false)}};
      {{wait_for_set!(d, osc.ext_ready, false)}}?; 
    }
    {% endif %}
    {% endfor %}

    {% if has_pll %}
    // Turn on the PLL and wait for it to report ready 
    // #####################################################
    {{set_bit!(d, self.pll_power, false)}}; 
    {{wait_for_set!(d, self.pll_ready, false)}}?; 
    {% endif %}

    // Set the flash latency depending on the clock speed 
    // ########################################################
    let freq = self.config.{{sys_clk_mux.field_name}}_freq();
    {% for range in flash_latency.ranges %}
    if 
    {% if range.has_min %}{{range.min_code}}{% endif %}
    {% if range.has_min && range.has_max %}&&{% endif %}
    {% if range.has_max %}{{range.max_code}}{% endif %}
    {
      {{write_val!(d, self.flash_latency.path, range.bit_value, false)}};
    }
    {% endfor %}

    // Select the system clock. We do this after turning on the PLL in 
    // case the PLL is selected as the system clock source.            
    // #####################################################################
    {% for mux in multiplexers %}
    {% if mux.is_sys_clk_mux %}
    {{write_val!(d, mux.path, f!("self.config.{mux.field_name}_input as u32"), false)}};
    {{wait_for_val!(d, mux.path, f!("self.config.{mux.field_name}_input as u32"), false)}}?;
    {% endif %}
    {% endfor %}

    Ok(())
  }
}
