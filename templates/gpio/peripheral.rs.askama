use crate::{ set_bit, set_bit_itf, clear_bit, clear_bit_itf, write_val, write_val_itf };
use crate::gpio::{ PullDirection, DummyAltFunc, OutputType, OutputSpeed, DigitalValue };
use core::marker::PhantomData;
use core::ptr;
use cortex_m::interrupt;

use crate::{Error, Result};

{% let d = device %}

pub(crate) fn create() -> {{peripheral.struct_name}} {
  {{peripheral.struct_name}} {
    _private: (),
    {% for pin in peripheral.pins -%}
    has_{{pin.field_name}}: true,
    {% endfor %}
  }
}

#[allow(non_camel_case_types)]
pub struct {{peripheral.struct_name}} { 
  _private: (),
  {% for pin in peripheral.pins -%}
  has_{{pin.field_name}}: bool,
  {% endfor %}
}
impl {{peripheral.struct_name}} {

  pub fn owns_everything(&self) -> bool {
    {% for pin in peripheral.pins -%}
    self.has_{{pin.field_name}} &&
    {% endfor %}
    true
  }
  
  pub(crate) fn enable(&mut self) {
    {{set_bit!(d, self.peripheral.enable_field)}}
  }

  pub(crate) fn disable(&mut self) -> Result<()> {
    if !self.owns_everything() {
      return Err(Error::new("{{peripheral.struct_name}} must own all of its pins before being disabled."))
    }
    {{clear_bit!(d, self.peripheral.enable_field)}}
    Ok(())
  }

  {% for pin in peripheral.pins %}
  pub fn take_{{pin.field_name}}(&mut self) -> Result<{{pin.struct_name}}> {
    match self.has_{{pin.field_name}} {
      true => {
        self.has_{{pin.field_name}} = false;
        Ok({{pin.struct_name}} {
          _private: ()
        })
      },
      false => Err(Error::new("{{pin.struct_name}} is already taken.")),
    }
  }

  pub fn return_{{pin.field_name}}(&mut self, {{pin.field_name}}: {{pin.struct_name}}) -> Result<()> {
    match self.has_{{pin.field_name}} {
      false => {
        self.has_{{pin.field_name}} = true;
        Ok(())
      },
      true => Err(Error::new("{{pin.struct_name}} is already owned by the peripheral.")),
    }
  }
  {% endfor %}
}

{% for pin in peripheral.pins %} 
pub struct {{pin.struct_name}} {
  _private: ()
}
impl {{pin.struct_name}} {
  pub fn as_input(self, pull_dir: PullDirection) -> {{pin.struct_name}}Input {
    interrupt::free(|_| {
      {{write_val!(d, pin.moder_field, "0b00", false)}}
      {{write_val!(d, pin.pupdr_field, "pull_dir.val()", false)}}
    });
    {{pin.struct_name}}Input { _private: () }
  }

  pub fn as_output(
    self, 
    pull_dir: PullDirection, 
    output_type: OutputType, 
    output_speed: OutputSpeed
  ) -> {{pin.struct_name}}Output {
    interrupt::free(|_| {
      {{write_val!(d, pin.moder_field, "0b01", false)}}
      {{write_val!(d, pin.pupdr_field, "pull_dir.val()", false)}}
      {{write_val!(d, pin.otyper_field, "output_type.val()", false)}}
      {{write_val!(d, pin.ospeedr_field, "output_speed.val()", false)}}
    });
    {{pin.struct_name}}Output { _private: () }
  }

  pub fn as_analog(self) -> {{pin.struct_name}}Analog {
    {{write_val!(d, pin.moder_field, "0b11")}}
    {{pin.struct_name}}Analog { _private: () }
  }

  #[allow(non_camel_case_types)]
  pub fn as_alt_func<ALT_FUNC>(
    self, 
    pull_dir: PullDirection, 
  ) -> {{pin.struct_name}}AltFunc<ALT_FUNC> 
  where ALT_FUNC: DummyAltFunc
  {
    interrupt::free(|_| {
      {{write_val!(d, pin.moder_field, "0b10", false)}}
      {{write_val!(d, pin.pupdr_field, "pull_dir.val()", false)}}
    });
    {{pin.struct_name}}AltFunc {
      alt_func: PhantomData
    }
  }
}

pub struct {{pin.struct_name}}Input { _private: () }

pub struct {{pin.struct_name}}Output { 
  _private: () 
}
impl {{pin.struct_name}}Output {
  pub fn write(&mut self, value: DigitalValue) {
    {{write_val!(d, pin.odr_field, "value.val()")}}
  }

  pub fn teardown(self) -> {{pin.struct_name}} {
    interrupt::free(|_| {
      {{reset!(d, pin.odr_field, false)}}
      {{reset!(d, pin.otyper_field, false)}}
      {{reset!(d, pin.ospeedr_field, false)}}
      {{reset!(d, pin.moder_field, false)}}
    });
    {{pin.struct_name}} { _private: () } 
  }
}

pub struct {{pin.struct_name}}Analog { _private: () }

#[allow(non_camel_case_types)]
pub struct {{pin.struct_name}}AltFunc<ALT_FUNC> 
  where ALT_FUNC: DummyAltFunc
{ 
  alt_func: PhantomData<ALT_FUNC>
}

{% endfor %}