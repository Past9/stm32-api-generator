use crate::{ set_bit_itf, clear_bit_itf, write_val, write_val_itf, is_set };
use crate::gpio::{ PullDirection, DummyAltFunc, OutputType, OutputSpeed, DigitalValue };
use core::marker::PhantomData;
use core::ptr;
use cortex_m::interrupt;

use crate::{Error, Result};

{% let d = device %}

pub(crate) fn create() -> {{peripheral.struct_name}} {
  {{peripheral.struct_name}} {
    _private: (),
    {% for pin in peripheral.pins -%}
    has_{{pin.field_name}}: true,
    {% endfor %}
  }
}

#[allow(non_camel_case_types)]
pub struct {{peripheral.struct_name}} { 
  _private: (),
  {% for pin in peripheral.pins -%}
  has_{{pin.field_name}}: bool,
  {% endfor %}
}
impl {{peripheral.struct_name}} {

  pub fn owns_everything(&self) -> bool {
    {% for pin in peripheral.pins -%}
    self.has_{{pin.field_name}} &&
    {% endfor %}
    true
  }
  
  pub(crate) fn enable(&mut self) {
    {{set_bit!(d, self.peripheral.enable_field)}}
  }

  pub(crate) fn disable(&mut self) -> Result<()> {
    if !self.owns_everything() {
      return Err(Error::new("{{peripheral.struct_name}} must own all of its pins before being disabled."))
    }
    {{clear_bit!(d, self.peripheral.enable_field)}};
    Ok(())
  }

  {% for pin in peripheral.pins %}
  pub fn take_{{pin.field_name}}(&mut self) -> Result<{{pin.struct_name}}> {
    match self.has_{{pin.field_name}} {
      true => {
        self.has_{{pin.field_name}} = false;
        Ok({{pin.struct_name}} {
          _private: ()
        })
      },
      false => Err(Error::new("{{pin.struct_name}} is already taken.")),
    }
  }

  pub fn return_{{pin.field_name}}(&mut self, #[allow(unused_variables)] {{pin.field_name}}: {{pin.struct_name}}) -> Result<()> {
    match self.has_{{pin.field_name}} {
      false => {
        self.has_{{pin.field_name}} = true;
        Ok(())
      },
      true => Err(Error::new("{{pin.struct_name}} is already owned by the peripheral.")),
    }
  }
  {% endfor %}
}

{% for pin in peripheral.pins %} 
pub struct {{pin.struct_name}} {
  _private: ()
}
impl {{pin.struct_name}} {
  pub fn as_input(self, pull_dir: PullDirection) -> {{pin.struct_name}}Input {
    {{pin.struct_name}}Input::setup(pull_dir) 
  }

  pub fn as_output(
    self, 
    pull_dir: PullDirection, 
    output_type: OutputType, 
    output_speed: OutputSpeed
  ) -> {{pin.struct_name}}Output {
    {{pin.struct_name}}Output::setup(pull_dir, output_type, output_speed)
  }

  pub fn as_analog(self) -> {{pin.struct_name}}Analog {
    {{pin.struct_name}}Analog::setup() 
  }


  {% if pin.alt_funcs.len() > 0 %}
  #[allow(non_camel_case_types)]
  pub fn as_alt_func<AltFunc>(self, pull_dir: PullDirection) -> {{pin.struct_name}}AltFunc<AltFunc> 
  where AltFunc: {{pin.struct_name}}AltFuncs
  {
    {{pin.struct_name}}AltFunc::setup(pull_dir)
  }
  {% endif %}
}

pub struct {{pin.struct_name}}Input { 
  _private: () 
}
impl {{pin.struct_name}}Input {
  pub fn read(&self) -> DigitalValue {
    DigitalValue::from_bool({{is_set!(d, pin.idr_field)}})
  }

  fn setup(pull_dir: PullDirection) -> Self {
    interrupt::free(|_| {
      {{write_val!(d, pin.moder_field, "0b00", false)}};
      {{write_val!(d, pin.pupdr_field, "pull_dir.val()", false)}};
    });
    Self { _private: () }
  }

  pub fn teardown(self) -> {{pin.struct_name}} {
    interrupt::free(|_| {
      {{reset!(d, pin.moder_field, false)}};
      {{reset!(d, pin.pupdr_field, false)}};
    });
    {{pin.struct_name}} { _private: () } 
  }
}

pub struct {{pin.struct_name}}Output { 
  _private: () 
}
impl {{pin.struct_name}}Output {
  pub fn write(&mut self, value: DigitalValue) {
    {{write_val!(d, pin.odr_field, "value.val()")}};
  }

  fn setup(pull_dir: PullDirection, output_type: OutputType, output_speed: OutputSpeed) -> Self {
    interrupt::free(|_| {
      {{write_val!(d, pin.moder_field, "0b01", false)}};
      {{write_val!(d, pin.pupdr_field, "pull_dir.val()", false)}};
      {{write_val!(d, pin.otyper_field, "output_type.val()", false)}};
      {{write_val!(d, pin.ospeedr_field, "output_speed.val()", false)}};
    });
    Self { _private: () }
  }

  pub fn teardown(self) -> {{pin.struct_name}} {
    interrupt::free(|_| {
      {{reset!(d, pin.odr_field, false)}};
      {{reset!(d, pin.pupdr_field, false)}};
      {{reset!(d, pin.otyper_field, false)}};
      {{reset!(d, pin.ospeedr_field, false)}};
      {{reset!(d, pin.moder_field, false)}};
    });
    {{pin.struct_name}} { _private: () } 
  }
}

pub struct {{pin.struct_name}}Analog { 
  _private: () 
}
impl {{pin.struct_name}}Analog {
  fn setup() -> Self {
    {{write_val!(d, pin.moder_field, "0b11")}};
    Self { _private: () }
  }

  pub fn teardown(self) -> {{pin.struct_name}} {
    interrupt::free(|_| {
      {{reset!(d, pin.moder_field)}};
    });
    {{pin.struct_name}} { _private: () } 
  }
}

{% if pin.alt_funcs.len() > 0 %}
pub trait {{pin.struct_name}}AltFuncs { 
  const AFR_VAL: u32;
  //fn configure(); 
}
{% for alt_func in pin.alt_funcs -%}
pub struct {{pin.struct_name}}{{alt_func.struct_name}}; // {{alt_func.field_name}} {{alt_func.value}}
impl {{pin.struct_name}}AltFuncs for {{pin.struct_name}}{{alt_func.struct_name}} {
  const AFR_VAL: u32 = {{alt_func.value}};
}
{% endfor %}

#[allow(non_camel_case_types)]
pub struct {{pin.struct_name}}AltFunc<AltFunc> 
  where AltFunc: {{pin.struct_name}}AltFuncs
{ 
  alt_func: PhantomData<AltFunc>
}
impl <AltFunc> {{pin.struct_name}}AltFunc<AltFunc> 
  where AltFunc: {{pin.struct_name}}AltFuncs
{
  fn setup(pull_dir: PullDirection) -> Self {
    interrupt::free(|_| {
      {{write_val!(d, pin.pupdr_field, "pull_dir.val()", false)}};
      {{write_val!(d, pin.afr_field, "AltFunc::AFR_VAL", false)}};
      {{write_val!(d, pin.moder_field, "0b10", false)}};
    });
    Self {
      alt_func: PhantomData
    }
  }

  pub fn teardown(self) -> {{pin.struct_name}} {
    interrupt::free(|_| {
      {{reset!(d, pin.moder_field, false)}};
      {{reset!(d, pin.pupdr_field, false)}};
      {{reset!(d, pin.afr_field, false)}};
    });
    {{pin.struct_name}} { _private: () } 
  }
}
{% endif %}


{% endfor %}