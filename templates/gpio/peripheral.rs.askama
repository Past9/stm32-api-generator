use crate::{ set_bit_itf, clear_bit_itf, write_val, write_val_itf, is_set };
use crate::gpio::{ PullDirection, OutputType, OutputSpeed, DigitalValue };
use core::marker::PhantomData;
use cortex_m::interrupt;


{% let d = d %}

use crate::{Error, Result};

#[allow(non_camel_case_types)]
pub struct {{g.name.camel()}} { 
  _no_construct: (),
  {% for pin in g.pins -%}
  has_{{pin.name.snake()}}: bool,
  {% endfor %}
}
impl {{g.name.camel()}} {

  pub(crate) fn create() -> Result<Self> {
    Ok(Self {
      _no_construct: (),
      {% for pin in g.pins -%}
      has_{{pin.name.snake()}}: true,
      {% endfor %}
    })
  }

  pub fn owns_everything(&self) -> bool {
    {% for pin in g.pins -%}
    self.has_{{pin.name.snake()}} &&
    {% endfor %}
    true
  }
  
  pub(crate) fn enable(&mut self) {
    {{set_bit!(d, self.g.enable_field)}}
  }

  pub(crate) fn disable(&mut self) -> Result<()> {
    if !self.owns_everything() {
      return Err(Error::new("{{g.name.camel()}} must own all of its pins before being disabled."))
    }
    {{clear_bit!(d, self.g.enable_field)}};
    Ok(())
  }

  {% for pin in g.pins %}
  pub fn take_{{pin.name.snake()}}(&mut self) -> Result<{{pin.name.camel()}}> {
    match self.has_{{pin.name.snake()}} {
      true => {
        self.has_{{pin.name.snake()}} = false;
        Ok({{pin.name.camel()}} {
          _no_construct: ()
        })
      },
      false => Err(Error::new("{{pin.name.camel()}} is already taken.")),
    }
  }

  pub fn return_{{pin.name.snake()}}(&mut self, #[allow(unused_variables)] {{pin.name.snake()}}: {{pin.name.camel()}}) -> Result<()> {
    match self.has_{{pin.name.snake()}} {
      false => {
        self.has_{{pin.name.snake()}} = true;
        Ok(())
      },
      true => Err(Error::new("{{pin.name.camel()}} is already owned.")),
    }
  }
  {% endfor %}
}

{% for pin in g.pins %} 
pub struct {{pin.name.camel()}} {
  _no_construct: ()
}
impl {{pin.name.camel()}} {
  pub fn as_input(self, pull_dir: PullDirection) -> {{pin.name.camel()}}Input {
    {{pin.name.camel()}}Input::setup(pull_dir) 
  }

  pub fn as_output(
    self, 
    pull_dir: PullDirection, 
    output_type: OutputType, 
    output_speed: OutputSpeed
  ) -> {{pin.name.camel()}}Output {
    {{pin.name.camel()}}Output::setup(pull_dir, output_type, output_speed)
  }

  pub fn as_analog(self) -> {{pin.name.camel()}}Analog {
    {{pin.name.camel()}}Analog::setup() 
  }


  {% if pin.alt_funcs.len() > 0 %}
  #[allow(non_camel_case_types)]
  pub fn as_alt_func<AltFunc>(self, pull_dir: PullDirection) -> {{pin.name.camel()}}AltFunc<AltFunc> 
  where AltFunc: {{pin.name.camel()}}AltFuncs
  {
    {{pin.name.camel()}}AltFunc::setup(pull_dir)
  }
  {% endif %}
}

pub struct {{pin.name.camel()}}Input { 
  _no_construct: () 
}
impl {{pin.name.camel()}}Input {
  pub fn read(&self) -> DigitalValue {
    DigitalValue::from_bool({{is_set!(d, pin.idr_field)}})
  }

  fn setup(pull_dir: PullDirection) -> Self {
    interrupt::free(|_| {
      {{write_val!(d, pin.moder_field, "0b00", false)}};
      {{write_val!(d, pin.pupdr_field, "pull_dir.val()", false)}};
    });
    Self { _no_construct: () }
  }

  pub fn teardown(self) -> {{pin.name.camel()}} {
    interrupt::free(|_| {
      {{reset!(d, pin.moder_field, false)}};
      {{reset!(d, pin.pupdr_field, false)}};
    });
    {{pin.name.camel()}} { _no_construct: () } 
  }
}

pub struct {{pin.name.camel()}}Output { 
  _no_construct: () 
}
impl {{pin.name.camel()}}Output {
  pub fn write(&mut self, value: DigitalValue) {
    {{write_val!(d, pin.odr_field, "value.val()")}};
  }

  fn setup(pull_dir: PullDirection, output_type: OutputType, output_speed: OutputSpeed) -> Self {
    interrupt::free(|_| {
      {{write_val!(d, pin.moder_field, "0b01", false)}};
      {{write_val!(d, pin.pupdr_field, "pull_dir.val()", false)}};
      {{write_val!(d, pin.otyper_field, "output_type.val()", false)}};
      {{write_val!(d, pin.ospeedr_field, "output_speed.val()", false)}};
    });
    Self { _no_construct: () }
  }

  pub fn teardown(self) -> {{pin.name.camel()}} {
    interrupt::free(|_| {
      {{reset!(d, pin.odr_field, false)}};
      {{reset!(d, pin.pupdr_field, false)}};
      {{reset!(d, pin.otyper_field, false)}};
      {{reset!(d, pin.ospeedr_field, false)}};
      {{reset!(d, pin.moder_field, false)}};
    });
    {{pin.name.camel()}} { _no_construct: () } 
  }
}

pub struct {{pin.name.camel()}}Analog { 
  _no_construct: () 
}
impl {{pin.name.camel()}}Analog {
  fn setup() -> Self {
    {{write_val!(d, pin.moder_field, "0b11")}};
    Self { _no_construct: () }
  }

  pub fn teardown(self) -> {{pin.name.camel()}} {
    interrupt::free(|_| {
      {{reset!(d, pin.moder_field)}};
    });
    {{pin.name.camel()}} { _no_construct: () } 
  }
}

{% if pin.alt_funcs.len() > 0 %}
pub trait {{pin.name.camel()}}AltFuncs { 
  const AFR_VAL: u32;
}
{% for alt_func in pin.alt_funcs -%}
pub struct {{pin.name.camel()}}{{alt_func.name.camel()}}; // {{alt_func.name.snake()}} {{alt_func.bit_value}}
impl {{pin.name.camel()}}AltFuncs for {{pin.name.camel()}}{{alt_func.name.camel()}} {
  const AFR_VAL: u32 = {{alt_func.bit_value}};
}
{% endfor %}

#[allow(non_camel_case_types)]
pub struct {{pin.name.camel()}}AltFunc<AltFunc> 
  where AltFunc: {{pin.name.camel()}}AltFuncs
{ 
  alt_func: PhantomData<AltFunc>
}
impl <AltFunc> {{pin.name.camel()}}AltFunc<AltFunc> 
  where AltFunc: {{pin.name.camel()}}AltFuncs
{
  fn setup(pull_dir: PullDirection) -> Self {
    interrupt::free(|_| {
      {{write_val!(d, pin.pupdr_field, "pull_dir.val()", false)}};
      {{write_val!(d, pin.afr_field, "AltFunc::AFR_VAL", false)}};
      {{write_val!(d, pin.moder_field, "0b10", false)}};
    });
    Self {
      alt_func: PhantomData
    }
  }

  pub fn teardown(self) -> {{pin.name.camel()}} {
    interrupt::free(|_| {
      {{reset!(d, pin.moder_field, false)}};
      {{reset!(d, pin.pupdr_field, false)}};
      {{reset!(d, pin.afr_field, false)}};
    });
    {{pin.name.camel()}} { _no_construct: () } 
  }
}
{% endif %}


{% endfor %}
