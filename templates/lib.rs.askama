#![no_std]

use core::{mem, ptr};
use cortex_m::interrupt;

pub type Result<T> = core::result::Result<T, Error>;

pub mod clocks;
pub mod gpio;

use clocks::{ Clocks, ClockConfig };

{% for submodule in submodules -%}
use gpio::{{submodule.module_name}}::{{submodule.struct_name}};
{% endfor %}

pub struct System {
  clocks: Clocks,
  {% for submodule in submodules -%}
  has_{{submodule.field_name}}: bool,
  {% endfor %}
}
impl System {
  pub fn new(clock_config: ClockConfig) -> Self {
    Self {
      clocks: Clocks::new(clock_config),
      {% for submodule in submodules -%}
      has_{{submodule.field_name}}: true,
      {% endfor %}
    }
  }

  pub fn get_freqs(&self) -> &ClockConfig {
    self.clocks.get_config()
  }

  pub fn owns_everything(&self) -> bool {
    {% for submodule in submodules -%}
    self.has_{{submodule.field_name}} &&
    {% endfor %}
    true
  }

  {% for submodule in submodules -%}
  pub fn activate_{{submodule.field_name}}(&mut self) -> Result<{{submodule.struct_name}}> {
    match self.has_{{submodule.field_name}} {
      true => {
        self.has_{{submodule.field_name}} = false;
        let mut {{submodule.field_name}} = gpio::{{submodule.module_name}}::create();
        {{submodule.field_name}}.enable();
        Ok({{submodule.field_name}})
      },
      false => Err(Error::new("{{submodule.struct_name}} is already active.")),
    }
  }

  pub fn deactivate_{{submodule.field_name}}(&mut self, mut {{submodule.field_name}}: {{submodule.struct_name}}) -> Result<()> {
    match self.has_{{submodule.field_name}} {
      false => { 
        {{submodule.field_name}}.disable()?; 
        self.has_{{submodule.field_name}} = true;
        Ok(())
      },
      true => Err(Error::new("{{submodule.struct_name}} is already deactivated.")),
    }
  }
  {% endfor %}

}

pub trait PowerStatus {}
pub struct Enabled;
pub struct Disabled;
impl PowerStatus for Enabled {}
impl PowerStatus for Disabled {}

pub struct Error {
  pub message: &'static str
}
impl Error {
  pub fn new(message: &'static str) -> Self  {
    Self {
      message
    }
  }
}

#[inline]
#[allow(dead_code)]
pub(crate) fn set_bit(address: u32, mask: u32) {
  unsafe {
    ptr::write_volatile(
      address as *mut u32,
      ptr::read_volatile(address as *const u32) | mask
    )
  }
}

#[inline]
#[allow(dead_code)]
pub(crate) fn set_bit_itf(address: u32, mask: u32) {
  interrupt::free(|_| set_bit(address, mask));
}

#[inline]
#[allow(dead_code)]
pub(crate) fn clear_bit(address: u32, mask: u32) {
  unsafe {
    ptr::write_volatile(
      address as *mut u32,
      ptr::read_volatile(address as *const u32) & !mask
    )
  }
}

#[inline]
#[allow(dead_code)]
pub(crate) fn clear_bit_itf(address: u32, mask: u32) {
  interrupt::free(|_| clear_bit(address, mask));
}

#[inline]
#[allow(dead_code)]
pub(crate) fn write_val(address: u32, mask: u32, offset: u32, val: u32) {
  unsafe {
    ptr::write_volatile(
      address as *mut u32,
      !mask & ptr::read_volatile(address as *const u32) | mask & (val << offset)
    );
  }
}

#[inline]
#[allow(dead_code)]
pub(crate) fn write_val_itf(address: u32, mask: u32, offset: u32, val: u32) {
  interrupt::free(|_| write_val(address, mask, offset, val))
}

#[inline]
#[allow(dead_code)]
pub(crate) fn read_val(address: u32, mask: u32, offset: u32) -> u32 {
  unsafe {
    (ptr::read_volatile(address as *const u32) & mask) >> offset
  }
}

#[inline]
#[allow(dead_code)]
pub(crate) fn wait_for_val(address: u32, mask: u32, offset: u32, val: u32) {
  let awaited_val = val << offset; 
  loop {
    unsafe {
      if (ptr::read_volatile(address as *const u32) & mask) == awaited_val {
        break;
      }
    }
  }
}

#[inline]
#[allow(dead_code)]
pub(crate) fn wait_for_val_itf(address: u32, mask: u32, offset: u32, val: u32) {
  interrupt::free(|_| wait_for_val(address, mask, offset, val));
}

#[inline]
#[allow(dead_code)]
pub(crate) fn wait_for_clear(address: u32, mask: u32, offset: u32) {
  loop {
    unsafe {
      if (ptr::read_volatile(address as *const u32) & mask) == 0{
        break;
      }
    }
  }
}

#[inline]
#[allow(dead_code)]
pub(crate) fn wait_for_val_clear_itf(address: u32, mask: u32, offset: u32) {
  interrupt::free(|_| wait_for_clear(address, mask, offset));
}

#[inline]
#[allow(dead_code)]
pub(crate) fn wait_for_set(address: u32, mask: u32, offset: u32) {
  loop {
    unsafe {
      if (ptr::read_volatile(address as *const u32) & mask) != 0{
        break;
      }
    }
  }
}

#[inline]
#[allow(dead_code)]
pub(crate) fn wait_for_val_set_itf(address: u32, mask: u32, offset: u32) {
  interrupt::free(|_| wait_for_set(address, mask, offset));
}