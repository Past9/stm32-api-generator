#![no_std]

use core::{mem, ptr};
use cortex_m::interrupt;

pub type Result<T> = core::result::Result<T, Error>;

pub mod gpio;

{% for submodule in submodules -%}
use gpio::{{submodule.module_name}}::{{submodule.struct_name}};
{% endfor %}

pub struct System {
  {% for submodule in submodules -%}
  has_{{submodule.field_name}}: bool,
  {% endfor %}
}
impl System {
  pub fn new() -> Self {
    Self {
      {% for submodule in submodules -%}
      has_{{submodule.field_name}}: true,
      {% endfor %}
    }
  }

  pub fn owns_everything(&self) -> bool {
    {% for submodule in submodules -%}
    self.has_{{submodule.field_name}} &&
    {% endfor %}
    true
  }

  {% for submodule in submodules -%}
  pub fn activate_{{submodule.field_name}}(&mut self) -> Result<{{submodule.struct_name}}> {
    match self.has_{{submodule.field_name}} {
      true => {
        self.has_{{submodule.field_name}} = false;
        let mut {{submodule.field_name}} = gpio::{{submodule.module_name}}::create();
        {{submodule.field_name}}.enable();
        Ok({{submodule.field_name}})
      },
      false => Err(Error::new("{{submodule.struct_name}} is already active.")),
    }
  }

  pub fn deactivate_{{submodule.field_name}}(&mut self, mut {{submodule.field_name}}: {{submodule.struct_name}}) -> Result<()> {
    match self.has_{{submodule.field_name}} {
      false => { 
        {{submodule.field_name}}.disable()?; 
        self.has_{{submodule.field_name}} = true;
        Ok(())
      },
      true => Err(Error::new("{{submodule.struct_name}} is already deactivated.")),
    }
  }
  {% endfor %}

}

pub trait PowerStatus {}
pub struct Enabled;
pub struct Disabled;
impl PowerStatus for Enabled {}
impl PowerStatus for Disabled {}

pub struct Error {
  pub message: &'static str
}
impl Error {
  pub fn new(message: &'static str) -> Self  {
    Self {
      message
    }
  }
}

#[inline]
pub(crate) fn set_bit(address: u32, mask: u32) {
  interrupt::free(|_| unsafe {
    ptr::write_volatile(
      address as *mut u32,
      ptr::read_volatile(address as *const u32) | mask
    )
  });
}

#[inline]
pub(crate) fn clear_bit(address: u32, inverse_mask: u32) {
  interrupt::free(|_| unsafe {
    ptr::write_volatile(
      address as *mut u32,
      ptr::read_volatile(address as *const u32) & inverse_mask
    )
  });
}

#[inline]
pub(crate) fn write_val(address: u32, mask: u32, inverse_mask: u32, offset: u32, val: u32) {
  interrupt::free(|_| unsafe {
    ptr::write_volatile(
      address as *mut u32,
      inverse_mask & ptr::read_volatile(address as *const u32) | mask & (val << offset)
    )
  });
}