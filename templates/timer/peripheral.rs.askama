{% let d = d %}

use crate::{ write_val_itf, read_val, set_bit_itf };
use crate::{Error, Result};


pub struct {{t.name.camel()}} {
  _no_construct: (),
  {% for channel in t.channels -%}
  has_{{channel.name.snake()}}: bool,
  {% endfor %}
}
impl {{t.name.camel()}} {

  pub(crate) fn create() -> Self {
    Self {
      _no_construct: (),
      {% for channel in t.channels -%}
      has_{{channel.name.snake()}}: true,
      {% endfor %}
    }
  }

  pub fn owns_everything(&self) -> bool {
    {% for channel in t.channels -%}
    self.has_{{channel.name.snake()}} &&
    {% endfor %}
    true
  }

  {% for channel in t.channels %}
  pub fn take_{{channel.name.snake()}}(&mut self) -> Result<{{t.name.camel()}}{{channel.name.camel()}}> {
    match self.has_{{channel.name.snake()}} {
      true => {
        self.has_{{channel.name.snake()}} = false;
        Ok({{t.name.camel()}}{{channel.name.camel()}}::setup())
      },
      false => Err(Error::new("{{channel.name.camel()}} is already taken."))
    }
  }

  pub fn return_{{channel.name.snake()}}(&mut self, #[allow(unused_variables)] {{channel.name.snake()}}: {{t.name.camel()}}{{channel.name.camel()}}) -> Result<()> {
    match self.has_{{channel.name.snake()}} {
      false => {
        self.has_{{channel.name.snake()}} = true;
        Ok(())
      }
      true => Err(Error::new("{{channel.name.camel()}} is already owned."))
    }
  }
  {% endfor %}

  pub(crate) fn enable(&mut self) {
    {{set_bit!(d, self.t.enable_field)}};
  }

  pub(crate) fn disable(&mut self) -> Result<()> {
    {{set_bit!(d, self.t.enable_field)}};
    Ok(())
  }

  pub fn set_prescaler(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{t.prescaler_field.min}} => Err(Error::new("Prescaler value must be at least {{t.prescaler_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{t.prescaler_field.max}} => Err(Error::new("Prescaler value must be at most {{t.prescaler_field.max}}")),
      v => {
        {{write_val!(d, self.t.prescaler_field.path, "v")}};
        Ok(())
      }
    }
  }

  pub fn get_prescaler(&self) -> u32 {
    {{read_val!(d, self.t.prescaler_field.path)}}
  }

  pub fn set_auto_reload(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{t.auto_reload_field.min}} => Err(Error::new("Auto-reload value must be at least {{t.auto_reload_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{t.auto_reload_field.max}} => Err(Error::new("Auto-reload value must be at most {{t.auto_reload_field.max}}")),
      v => {
        {{write_val!(d, self.t.auto_reload_field.path, "v")}};
        Ok(())
      }
    }
  }

  pub fn get_auto_reload(&self) -> u32 {
    {{read_val!(d, self.t.auto_reload_field.path)}}
  }

  pub fn get_count(&self) -> u32 {
    {{read_val!(d, self.t.counter_field.path)}}
  }
}


{% for channel in t.channels %}
// {{channel.name.snake()}} {% if channel.input.is_some() %}INPUT {% endif %} {% if channel.output.is_some() %}OUTPUT {% endif %}
pub struct {{t.name.camel()}}{{channel.name.camel()}} {
  _no_construct: ()
}
impl {{t.name.camel()}}{{channel.name.camel()}} {
  pub(crate) fn setup() -> Self {
    Self {
      _no_construct: ()
    }
  } 

  {% if channel.is_output() -%}
  pub fn as_output(self,
    {% if channel.as_output().has_io_select() && channel.as_output().io_select().values.len() > 1 %}
    mode: {{t.name.camel()}}{{channel.name.camel()}}OutputMode
    {% endif %}
  ) -> {{t.name.camel()}}{{channel.name.camel()}}Output {
    {{t.name.camel()}}{{channel.name.camel()}}Output::setup(
      {% if channel.as_output().has_io_select() && channel.as_output().io_select().values.len() > 1 %}mode{% endif %}
    ) 
  } 
  {% endif %}

  {% if channel.is_input() -%}
  pub fn as_input(self,
    {% if channel.as_input().has_io_select() && channel.as_input().io_select().values.len() > 1 %}
    mode: {{t.name.camel()}}{{channel.name.camel()}}InputMode
    {% endif %}
  ) -> {{t.name.camel()}}{{channel.name.camel()}}Input {
    {{t.name.camel()}}{{channel.name.camel()}}Input::setup(
      {% if channel.as_input().has_io_select() && channel.as_input().io_select().values.len() > 1 %}mode{% endif %}
    ) 
  } 
  {% endif %}
}

{% if channel.is_output() -%}
{% if channel.as_output().has_io_select() && channel.as_output().io_select().values.len() > 1 %}
pub enum {{t.name.camel()}}{{channel.name.camel()}}OutputMode {
  {% for value in channel.as_output().io_select().values -%}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}
{% endif %}

pub struct {{t.name.camel()}}{{channel.name.camel()}}Output {
  _no_construct: ()
}
impl {{t.name.camel()}}{{channel.name.camel()}}Output {
  {% if channel.as_output().has_io_select() %} 
  pub(crate) fn setup(
    {% if channel.as_output().io_select().values.len() > 1 %}
    mode: {{t.name.camel()}}{{channel.name.camel()}}OutputMode
    {% endif %}
  ) -> Self {
    {% if channel.as_output().io_select().values.len() == 0 %}
    {% else if channel.as_output().io_select().values.len() == 1 %}
    {{write_val!(d, channel.as_output().io_select().path, channel.as_output().io_select().values[0].bit_value)}};
    {% else %}
    let val = match mode {
      {% for value in channel.as_output().io_select().values -%}
      {{t.name.camel()}}{{channel.name.camel()}}OutputMode::{{value.name.camel()}} = {{value.bit_value}},
      {% endfor %}
    };
    {{write_val!(d, channel.as_output().io_select().path, "val")}};
    {% endif %}
    Self {
      _no_construct: ()
    }
  } 
  {% else %}
  pub(crate) fn setup() -> Self {
    Self {
      _no_construct: ()
    }
  }
  {% endif %}
}
{% endif %}

{% if channel.is_input() -%}
{% if channel.as_input().has_io_select() && channel.as_input().io_select().values.len() > 1 %}
pub enum {{t.name.camel()}}{{channel.name.camel()}}InputMode {
  {% for value in channel.as_input().io_select().values -%}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}
{% endif %}

pub struct {{t.name.camel()}}{{channel.name.camel()}}Input {
  _no_construct: ()
}
impl {{t.name.camel()}}{{channel.name.camel()}}Input {
  {% if channel.as_input().has_io_select() %} 
  pub(crate) fn setup(
    {% if channel.as_input().io_select().values.len() > 1 %}
    mode: {{t.name.camel()}}{{channel.name.camel()}}InputMode
    {% endif %}
  ) -> Self {
    {% if channel.as_input().io_select().values.len() == 0 %}
    {% else if channel.as_input().io_select().values.len() == 1 %}
    {{write_val!(d, channel.as_input().io_select().path, channel.as_input().io_select().values[0].bit_value)}};
    {% else %}
    let val = match mode {
      {% for value in channel.as_input().io_select().values -%}
      {{t.name.camel()}}{{channel.name.camel()}}InputMode::{{value.name.camel()}} => {{value.bit_value}},
      {% endfor %}
    };
    {{write_val!(d, channel.as_input().io_select().path, "val")}};
    {% endif %}
    Self {
      _no_construct: ()
    }
  } 
  {% else %}
  pub(crate) fn setup() -> Self {
    Self {
      _no_construct: ()
    }
  }
  {% endif %}
}
{% endif %}
{% endfor %}
