{% let d = d %}

use crate::{ write_val_itf, read_val, set_bit_itf, clear_bit_itf };
use crate::{Error, Result};


pub struct {{t.name.camel()}} {
  _no_construct: (),
  {% for channel in t.channels -%}
  has_{{channel.name.snake()}}: bool,
  {% endfor %}
}
impl {{t.name.camel()}} {

  pub(crate) fn create() -> Self {
    Self {
      _no_construct: (),
      {% for channel in t.channels -%}
      has_{{channel.name.snake()}}: true,
      {% endfor %}
    }
  }

  pub fn owns_everything(&self) -> bool {
    {% for channel in t.channels -%}
    self.has_{{channel.name.snake()}} &&
    {% endfor %}
    true
  }

  {% for channel in t.channels %}
  pub fn take_{{channel.name.snake()}}(&mut self) -> Result<{{channel.name.camel()}}> {
    match self.has_{{channel.name.snake()}} {
      true => {
        self.has_{{channel.name.snake()}} = false;
        Ok({{channel.name.camel()}}::setup())
      },
      false => Err(Error::new("{{channel.name.camel()}} is already taken."))
    }
  }

  pub fn return_{{channel.name.snake()}}(&mut self, #[allow(unused_variables)] {{channel.name.snake()}}: {{channel.name.camel()}}) -> Result<()> {
    match self.has_{{channel.name.snake()}} {
      false => {
        self.has_{{channel.name.snake()}} = true;
        Ok(())
      }
      true => Err(Error::new("{{channel.name.camel()}} is already owned."))
    }
  }
  {% endfor %}

  pub(crate) fn enable(&mut self) {
    {{set_bit!(d, self.t.enable_field)}};
  }

  pub(crate) fn disable(&mut self) -> Result<()> {
    {{clear_bit!(d, self.t.enable_field)}};
    Ok(())
  }

  pub fn set_prescaler(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{t.prescaler_field.min}} => Err(Error::new("Prescaler value must be at least {{t.prescaler_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{t.prescaler_field.max}} => Err(Error::new("Prescaler value must be at most {{t.prescaler_field.max}}")),
      v => {
        {{write_val!(d, self.t.prescaler_field.path, "v")}};
        Ok(())
      }
    }
  }

  pub fn get_prescaler(&self) -> u32 {
    {{read_val!(d, self.t.prescaler_field.path)}}
  }

  pub fn set_auto_reload(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{t.auto_reload_field.min}} => Err(Error::new("Auto-reload value must be at least {{t.auto_reload_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{t.auto_reload_field.max}} => Err(Error::new("Auto-reload value must be at most {{t.auto_reload_field.max}}")),
      v => {
        {{write_val!(d, self.t.auto_reload_field.path, "v")}};
        Ok(())
      }
    }
  }

  pub fn get_auto_reload(&self) -> u32 {
    {{read_val!(d, self.t.auto_reload_field.path)}}
  }

  pub fn get_count(&self) -> u32 {
    {{read_val!(d, self.t.counter_field.path)}}
  }

  pub fn enable_auto_reload_preload(&mut self) {
    {{set_bit!(d, self.t.arpe_field)}};
  }

  pub fn disable_auto_reload_preload(&mut self) {
    {{clear_bit!(d, self.t.arpe_field)}};
  }

  pub fn initialize(&mut self) {
    {{set_bit!(d, self.t.ug_field)}};
  }
}


{% for channel in t.channels %}
pub struct {{channel.name.camel()}} {
  _no_construct: ()
}
impl {{channel.name.camel()}} {
  pub(crate) fn setup() -> Self {
    Self {
      _no_construct: ()
    }
  } 

  {% if channel.is_output() -%}
  pub fn as_output(self,
    {% if channel.as_output().has_io_select() && channel.as_output().io_select().values.len() > 1 %}
    output_mode: {{channel.name.camel()}}OutputMode,
    {% endif %}
    compare_mode: {{channel.name.camel()}}CompareMode
  ) -> {{channel.name.camel()}}Output {
    {{channel.name.camel()}}Output::setup(
      {% if channel.as_output().has_io_select() && channel.as_output().io_select().values.len() > 1 %}output_mode, {% endif %}
      compare_mode
    ) 
  } 
  {% endif %}

  {% if channel.is_input() -%}
  pub fn as_input(self,
    {% if channel.as_input().has_io_select() && channel.as_input().io_select().values.len() > 1 %}
    input_mode: {{channel.name.camel()}}InputMode,
    {% endif %}
    capture_filter: {{channel.name.camel()}}CaptureFilter
  ) -> {{channel.name.camel()}}Input {
    {{channel.name.camel()}}Input::setup(
      {% if channel.as_input().has_io_select() && channel.as_input().io_select().values.len() > 1 %}input_mode, {% endif %}
      capture_filter
    ) 
  } 
  {% endif %}
}



{% if channel.is_output() -%}

/// {{channel.as_output().compare_mode.description}}
pub enum {{channel.name.camel()}}CompareMode {
  {% for value in channel.as_output().compare_mode.values %}
  /// {{value.description}}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}

{% if channel.as_output().has_io_select() && channel.as_output().io_select().values.len() > 1 %}
/// {{channel.as_output().io_select().description}}
pub enum {{channel.name.camel()}}OutputMode {
  {% for value in channel.as_output().io_select().values -%}
  /// {{value.description}}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}
{% endif %}

pub struct {{channel.name.camel()}}Output {
  _no_construct: ()
}
impl {{channel.name.camel()}}Output {
  {% if channel.as_output().has_io_select() %} 
  pub(crate) fn setup(
    {% if channel.as_output().io_select().values.len() > 1 %}
    output_mode: {{channel.name.camel()}}OutputMode,
    {% endif %}
    compare_mode: {{channel.name.camel()}}CompareMode
  ) -> Self {
    {% if channel.as_output().io_select().values.len() == 0 %}
    {% else if channel.as_output().io_select().values.len() == 1 %}
    {{write_val!(d, channel.as_output().io_select().path, channel.as_output().io_select().values[0].bit_value)}};
    {% else %}
    {{write_val!(d, channel.as_output().io_select().path, "mode as u32")}};
    {% endif %}
    {{write_val!(d, channel.as_output().compare_mode.path, "compare_mode as u32")}};
    {{set_bit!(d, channel.as_output().enable_path)}};
    Self {
      _no_construct: ()
    }
  } 
  {% else %}
  pub(crate) fn setup(compare_mode: {{channel.name.camel()}}CompareMode) -> Self {
    {{write_val!(d, channel.as_output().compare_mode.path, "compare_mode as u32")}};
    {{set_bit!(d, channel.as_output().enable_path)}};
    Self {
      _no_construct: ()
    }
  }
  {% endif %}

  pub fn enable_preload(&mut self) {
    {{set_bit!(d, channel.as_output().preload_path)}};
  }

  pub fn disable_preload(&mut self) {
    {{clear_bit!(d, channel.as_output().preload_path)}};
  }

  pub fn set_compare_value(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{channel.as_output().compare_field.min}} => Err(Error::new("Compare value must be at least {{channel.as_output().compare_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{channel.as_output().compare_field.max}} => Err(Error::new("Compare value must be at most {{channel.as_output().compare_field.max}}")),
      v => {
        {{write_val!(d, channel.as_output().compare_field.path, "v")}};
        Ok(())
      }
    }
  }
}
{% endif %}

{% if channel.is_input() -%}

/// {{channel.as_input().capture_filter.description}}
pub enum {{channel.name.camel()}}CaptureFilter {
  {% for value in channel.as_input().capture_filter.values -%}
  /// {{value.description}}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}

{% if channel.as_input().has_io_select() && channel.as_input().io_select().values.len() > 1 %}
/// {{channel.as_input().io_select().description}}
pub enum {{channel.name.camel()}}InputMode {
  {% for value in channel.as_input().io_select().values -%}
  /// {{value.description}}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}
{% endif %}

pub struct {{channel.name.camel()}}Input {
  _no_construct: ()
}
impl {{channel.name.camel()}}Input {
  {% if channel.as_input().has_io_select() %} 
  pub(crate) fn setup(
    {% if channel.as_input().io_select().values.len() > 1 %}
    mode: {{channel.name.camel()}}InputMode,
    {% endif %}
    capture_filter: {{channel.name.camel()}}CaptureFilter
  ) -> Self {
    {% if channel.as_input().io_select().values.len() == 0 %}
    {% else if channel.as_input().io_select().values.len() == 1 %}
    {{write_val!(d, channel.as_input().io_select().path, channel.as_input().io_select().values[0].bit_value)}};
    {% else %}
    {{write_val!(d, channel.as_input().io_select().path, "mode as u32")}};
    {% endif %}
    {{write_val!(d, channel.as_input().capture_filter.path, "capture_filter as u32")}};
    {{set_bit!(d, channel.as_input().enable_path)}};
    Self {
      _no_construct: ()
    }
  } 
  {% else %}
  pub(crate) fn setup(capture_filter: {{channel.name.camel()}}CaptureFilter) -> Self {
    {{write_val!(d, channel.as_input().capture_filter.path, "capture_filter as u32")}};
    {{set_bit!(d, channel.as_input().enable_path)}};
    Self {
      _no_construct: ()
    }
  }
  {% endif %}
}
{% endif %}
{% endfor %}
