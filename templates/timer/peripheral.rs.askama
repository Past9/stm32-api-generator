{% let d = d %}

use crate::{ write_val_itf, read_val, set_bit_itf, clear_bit_itf, is_set, Error, Result, clocks::Clocks };
use super::ChannelPolarity;

pub struct {{t.name.camel()}} {
  _no_construct: (),
  source_freq: f32,
  {% for channel in t.channels -%}
  has_{{channel.name.snake()}}: bool,
  {% endfor %}
}
impl {{t.name.camel()}} {

  pub(crate) fn create(clocks: &Clocks) -> Result<Self> {
    Ok(Self {
      _no_construct: (),
      source_freq: clocks.actual_config()?.to_{{t.name.snake()}}_freq(),
      {% for channel in t.channels -%}
      has_{{channel.name.snake()}}: true,
      {% endfor %}
    })
  }

  pub fn source_freq(&self) -> f32 {
    self.source_freq
  }

  pub fn owns_everything(&self) -> bool {
    {% for channel in t.channels -%}
    self.has_{{channel.name.snake()}} &&
    {% endfor %}
    true
  }

  {% for channel in t.channels %}
  pub fn take_{{channel.name.snake()}}(&mut self) -> Result<{{channel.name.camel()}}> {
    match self.has_{{channel.name.snake()}} {
      true => {
        self.has_{{channel.name.snake()}} = false;
        Ok({{channel.name.camel()}}::setup(self.source_freq))
      },
      false => Err(Error::new("{{channel.name.camel()}} is already taken."))
    }
  }

  pub fn return_{{channel.name.snake()}}(&mut self, #[allow(unused_variables)] {{channel.name.snake()}}: {{channel.name.camel()}}) -> Result<()> {
    match self.has_{{channel.name.snake()}} {
      false => {
        self.has_{{channel.name.snake()}} = true;
        Ok(())
      }
      true => Err(Error::new("{{channel.name.camel()}} is already owned."))
    }
  }
  {% endfor %}

  pub(crate) fn enable(&mut self) {
    {{set_bit!(d, self.t.peripheral_enable_field)}};
  }

  pub(crate) fn disable(&mut self) -> Result<()> {
    {{clear_bit!(d, self.t.peripheral_enable_field)}};
    Ok(())
  }

  pub fn is_enabled(&self) -> bool {
    {{is_set!(d, self.t.peripheral_enable_field)}}
  }

  pub fn set_prescaler(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{t.prescaler_field.min}} => Err(Error::new("Prescaler value must be at least {{t.prescaler_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{t.prescaler_field.max}} => Err(Error::new("Prescaler value must be at most {{t.prescaler_field.max}}")),
      v => {
        {{write_val!(d, self.t.prescaler_field.path, "v")}};
        Ok(())
      }
    }
  }

  pub fn get_prescaler(&self) -> u32 {
    {{read_val!(d, self.t.prescaler_field.path)}}
  }

  pub fn set_auto_reload(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{t.auto_reload_field.min}} => Err(Error::new("Auto-reload value must be at least {{t.auto_reload_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{t.auto_reload_field.max}} => Err(Error::new("Auto-reload value must be at most {{t.auto_reload_field.max}}")),
      v => {
        {{write_val!(d, self.t.auto_reload_field.path, "v")}};
        Ok(())
      }
    }
  }

  pub fn get_auto_reload(&self) -> u32 {
    {{read_val!(d, self.t.auto_reload_field.path)}}
  }

  pub fn get_count(&self) -> u32 {
    {{read_val!(d, self.t.counter_field.path)}}
  }

  pub fn enable_auto_reload_preload(&mut self) {
    {{set_bit!(d, self.t.arpe_field)}};
  }

  pub fn disable_auto_reload_preload(&mut self) {
    {{clear_bit!(d, self.t.arpe_field)}};
  }

  pub fn is_auto_reload_preload_enabled(&mut self) -> bool {
    {{is_set!(d, self.t.arpe_field)}}
  }

  pub fn generate_update(&mut self) {
    {{set_bit!(d, self.t.ug_field)}};
  }

  pub fn enable_counter(&mut self) {
    {{set_bit!(d, self.t.cen_field)}};
  }

  pub fn disable_counter(&mut self) {
    {{clear_bit!(d, self.t.cen_field)}};
  }

  pub fn is_counter_enabled(&mut self) -> bool {
    {{is_set!(d, self.t.cen_field)}}
  }

  {% if t.has_moe_field() %}
  pub fn enable_outputs(&mut self) {
    {{set_bit!(d, self.t.moe_field())}};
  }

  pub fn disable_outputs(&mut self) {
    {{clear_bit!(d, self.t.moe_field())}};
  }

  pub fn are_outputs_enabled(&mut self) -> bool {
    {{is_set!(d, self.t.moe_field())}}
  }
  {% endif %}
}


{% for channel in t.channels %}
pub struct {{channel.name.camel()}} {
  _no_construct: (),
  source_freq: f32,
}
impl {{channel.name.camel()}} {
  pub(crate) fn setup(source_freq: f32) -> Self {
    Self {
      _no_construct: (),
      source_freq
    }
  } 

  {% if channel.is_output() -%}
  pub fn as_output(&mut self,
    {% if channel.as_output().has_io_select() && channel.as_output().io_select().values.len() > 1 %}
    output_mode: {{channel.name.camel()}}OutputMode,
    {% endif %}
    compare_mode: {{channel.name.camel()}}CompareMode
  ) -> {{channel.name.camel()}}Output {
    {{channel.name.camel()}}Output::setup(
      self.source_freq,
      {% if channel.as_output().has_io_select() && channel.as_output().io_select().values.len() > 1 %}output_mode, {% endif %}
      compare_mode
    ) 
  } 
  {% endif %}

  {% if channel.is_input() -%}
  pub fn as_input(self,
    {% if channel.as_input().has_io_select() && channel.as_input().io_select().values.len() > 1 %}
    input_mode: {{channel.name.camel()}}InputMode,
    {% endif %}
    capture_filter: {{channel.name.camel()}}CaptureFilter
  ) -> {{channel.name.camel()}}Input {
    {{channel.name.camel()}}Input::setup(
      {% if channel.as_input().has_io_select() && channel.as_input().io_select().values.len() > 1 %}input_mode, {% endif %}
      capture_filter
    ) 
  } 
  {% endif %}
}



{% if channel.is_output() -%}

/// {{channel.as_output().compare_mode.description}}
pub enum {{channel.name.camel()}}CompareMode {
  {% for value in channel.as_output().compare_mode.values %}
  /// {{value.description}}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}

{% if channel.as_output().has_io_select() && channel.as_output().io_select().values.len() > 1 %}
/// {{channel.as_output().io_select().description}}
pub enum {{channel.name.camel()}}OutputMode {
  {% for value in channel.as_output().io_select().values -%}
  /// {{value.description}}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}
{% endif %}

pub struct {{channel.name.camel()}}Output {
  _no_construct: (),
  source_freq: f32,
  {% if channel.as_output().has_complement() %}
  complement: {{channel.name.camel()}}OutputComplement
  {% endif %}
}
impl {{channel.name.camel()}}Output {
  {% if channel.as_output().has_io_select() %} 
  pub(crate) fn setup(
    source_freq: f32,
    {% if channel.as_output().io_select().values.len() > 1 %}
    output_mode: {{channel.name.camel()}}OutputMode,
    {% endif %}
    compare_mode: {{channel.name.camel()}}CompareMode
  ) -> Self {
    {% if channel.as_output().io_select().values.len() == 0 %}
    {% else if channel.as_output().io_select().values.len() == 1 %}
    {{write_val!(d, channel.as_output().io_select().path, channel.as_output().io_select().values[0].bit_value)}};
    {% else %}
    {{write_val!(d, channel.as_output().io_select().path, "mode as u32")}};
    {% endif %}
    {{write_val!(d, channel.as_output().compare_mode.path, "compare_mode as u32")}};
    {{set_bit!(d, channel.as_output().enable_path)}};
    Self {
      _no_construct: (),
      source_freq,
      {% if channel.as_output().has_complement() %}
      complement: {{channel.name.camel()}}OutputComplement::setup(source_freq) 
      {% endif %}
    }
  } 

  {% else %}
  pub(crate) fn setup(source_freq: f32, compare_mode: {{channel.name.camel()}}CompareMode) -> Self {
    {{write_val!(d, channel.as_output().compare_mode.path, "compare_mode as u32")}};
    {{set_bit!(d, channel.as_output().enable_path)}};
    Self {
      _no_construct: (),
      source_freq,
      {% if channel.as_output().has_complement() %}
      complement: {{channel.name.camel()}}OutputComplement::setup(source_freq) 
      {% endif %}
    }
  }
  {% endif %}

  pub fn teardown(self) -> Result<{{channel.name.camel()}}> {
    {% if channel.as_output().has_io_select() %} 
    {{reset!(d, channel.as_output().io_select().path)}};
    {% endif %}
    {{reset!(d, channel.as_output().compare_mode.path)}};
    {{reset!(d, channel.as_output().enable_path)}};
    Ok(
      {{channel.name.camel()}} { _no_construct: (), source_freq: self.source_freq }
    )
  } 

  {% if channel.as_output().has_complement() %}
  pub fn complement(&self) -> &{{channel.name.camel()}}OutputComplement {
    &self.complement
  }

  pub fn complement_mut(&mut self) -> &mut {{channel.name.camel()}}OutputComplement {
    &mut self.complement
  }
  {% endif %}

  pub fn enable_preload(&mut self) {
    {{set_bit!(d, channel.as_output().preload_path)}};
  }

  pub fn disable_preload(&mut self) {
    {{clear_bit!(d, channel.as_output().preload_path)}};
  }

  pub fn set_compare_value(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{channel.as_output().compare_field.min}} => Err(Error::new("Compare value must be at least {{channel.as_output().compare_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{channel.as_output().compare_field.max}} => Err(Error::new("Compare value must be at most {{channel.as_output().compare_field.max}}")),
      v => {
        {{write_val!(d, channel.as_output().compare_field.path, "v")}};
        Ok(())
      }
    }
  }

  pub fn set_polarity(&mut self, polarity: ChannelPolarity) {
    {{write_val!(d, channel.as_output().polarity_path, "polarity as u32")}};
  }

  pub fn get_polarity(&self) -> ChannelPolarity {
    match {{is_set!(d, channel.as_output().polarity_path)}} {
      true => ChannelPolarity::ActiveLow,
      false => ChannelPolarity::ActiveHigh
    }
  }

}

{% if channel.as_output().has_complement() %}
pub struct {{channel.name.camel()}}OutputComplement {
  _no_construct: (),
  source_freq: f32
}
impl {{channel.name.camel()}}OutputComplement {
  pub(crate) fn setup(source_freq: f32) -> Self {
    Self {
      _no_construct: (),
      source_freq
    }
  }

  pub fn enable(&mut self) {
    {{set_bit!(d, channel.as_output().complement().enable_path)}};
  }

  pub fn disable(&mut self) {
    {{clear_bit!(d, channel.as_output().complement().enable_path)}};
  }

  pub fn is_enabled(&self) -> bool {
    {{is_set!(d, channel.as_output().complement().enable_path)}}
  }

  pub fn set_polarity(&mut self, polarity: ChannelPolarity) {
    {{write_val!(d, channel.as_output().polarity_path, "polarity as u32")}};
  }

  pub fn get_polarity(&self) -> ChannelPolarity {
    match {{is_set!(d, channel.as_output().polarity_path)}} {
      true => ChannelPolarity::ActiveLow,
      false => ChannelPolarity::ActiveHigh
    }
  }

  pub fn set_deadtime(&mut self, duration: core::time::Duration) -> Result<()> {
    let num_cycles = (duration.as_secs_f32() * self.source_freq) as u32;
    let bits = match num_cycles {
      #[allow(unused_comparisons)]
      n if n >= 0 && n <= 127 => Ok(n),
      n if n >= 128 && n <= 254 => Ok(0b10000000 + (n / 2) - 64),
      n if n >= 256 && n <= 504 => Ok(0b11000000 + (n / 8) - 32),
      n if n >= 512 && n <= 1008 => Ok(0b11100000 + (n / 16) - 32),
      _ => Err(Error::new("Out of range")),
    }?;
    {{write_val!(d, channel.as_output().complement().dtg_path, "bits")}};
    Ok(())
  }
}
{% endif %}

{% endif %}

{% if channel.is_input() -%}

/// {{channel.as_input().capture_filter.description}}
pub enum {{channel.name.camel()}}CaptureFilter {
  {% for value in channel.as_input().capture_filter.values -%}
  /// {{value.description}}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}

{% if channel.as_input().has_io_select() && channel.as_input().io_select().values.len() > 1 %}
/// {{channel.as_input().io_select().description}}
pub enum {{channel.name.camel()}}InputMode {
  {% for value in channel.as_input().io_select().values -%}
  /// {{value.description}}
  {{value.name.camel()}} = {{value.bit_value}},
  {% endfor %}
}
{% endif %}

pub struct {{channel.name.camel()}}Input {
  _no_construct: ()
}
impl {{channel.name.camel()}}Input {
  {% if channel.as_input().has_io_select() %} 
  pub(crate) fn setup(
    {% if channel.as_input().io_select().values.len() > 1 %}
    mode: {{channel.name.camel()}}InputMode,
    {% endif %}
    capture_filter: {{channel.name.camel()}}CaptureFilter
  ) -> Self {
    {% if channel.as_input().io_select().values.len() == 0 %}
    {% else if channel.as_input().io_select().values.len() == 1 %}
    {{write_val!(d, channel.as_input().io_select().path, channel.as_input().io_select().values[0].bit_value)}};
    {% else %}
    {{write_val!(d, channel.as_input().io_select().path, "mode as u32")}};
    {% endif %}
    {{write_val!(d, channel.as_input().capture_filter.path, "capture_filter as u32")}};
    {{set_bit!(d, channel.as_input().enable_path)}};
    Self {
      _no_construct: ()
    }
  } 
  {% else %}
  pub(crate) fn setup(capture_filter: {{channel.name.camel()}}CaptureFilter) -> Self {
    {{write_val!(d, channel.as_input().capture_filter.path, "capture_filter as u32")}};
    {{set_bit!(d, channel.as_input().enable_path)}};
    Self {
      _no_construct: ()
    }
  }
  {% endif %}
}
{% endif %}
{% endfor %}
