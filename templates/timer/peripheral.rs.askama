{% let d = d %}

use crate::{ write_val_itf, read_val, set_bit_itf };
use crate::{Error, Result};
use super::BasicTimer;


pub struct {{t.name.camel()}} {
}
impl {{t.name.camel()}} {

  pub(crate) fn create() -> Self {
    Self {

    }
  }

  pub(crate) fn enable(&mut self) {
    {{set_bit!(d, self.t.enable_field)}};
  }

  pub(crate) fn disable(&mut self) -> Result<()> {
    {{set_bit!(d, self.t.enable_field)}};
    Ok(())
  }


  pub fn set_prescaler(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{t.prescaler_field.min}} => Err(Error::new("Prescaler value must be at least {{t.prescaler_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{t.prescaler_field.max}} => Err(Error::new("Prescaler value must be at most {{t.prescaler_field.max}}")),
      v => {
        {{write_val!(d, self.t.prescaler_field.path, "v")}};
        Ok(())
      }
    }
  }

  pub fn get_prescaler(&self) -> u32 {
    {{read_val!(d, self.t.prescaler_field.path)}}
  }

  pub fn set_auto_reload(&mut self, val: u32) -> Result<()> {
    match val {
      #[allow(unused_comparisons)]
      v if v < {{t.auto_reload_field.min}} => Err(Error::new("Auto-reload value must be at least {{t.auto_reload_field.min}}")), 
      #[allow(unused_comparisons)]
      v if v > {{t.auto_reload_field.max}} => Err(Error::new("Auto-reload value must be at most {{t.auto_reload_field.max}}")),
      v => {
        {{write_val!(d, self.t.auto_reload_field.path, "v")}};
        Ok(())
      }
    }
  }

  pub fn get_auto_reload(&self) -> u32 {
    {{read_val!(d, self.t.auto_reload_field.path)}}
  }

  pub fn get_count(&self) -> u32 {
    {{read_val!(d, self.t.counter_field.path)}}
  }

  // CHANNELS
  {% for channel in t.channels %}
  // {{channel.name.snake()}} {% if channel.input.is_some() %}INPUT {% endif %} {% if channel.output.is_some() %}OUTPUT {% endif %}
  {% endfor %}
}
impl BasicTimer for {{t.name.camel()}} {}
